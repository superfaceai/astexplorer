profile = "http://example.com/profile"
provider = "http://example.com/provider"

# Line comment

"""
Operation Foo
This operation showcases some of the syntax available in operations
"""
operation Foo {
  # set variable (without explicit set block)
  a = ["hello", "world"];
  b.c = 1 + 2 # semantically expands to: `b: { c: 1 + 2 }`
  
  d."e.e" = {
    f = 3, g = 4
  } # semantically expands to: `d: { e: { f: 3, g: 4 } }`

  # conditional set blocks have to be explicit
  set if (condition) {
    h = true; i = false
  }

  # fail with an object literal (with slang syntax) with a condition
  # `args` is a scope-injected variable holding the arguments passed from the caller
  fail if (args.fail) {
    code = 16
  }

  # return a literal with condition
  return if (b.c === 3) "early return";

  fail if (false) "error";

  # return a jessie literal without condition
  return `Hello ${a}`
}

operation Bar {
  # both maps and operations can call other operations
  call Foo(fail = false) if (bar) {
    # this scope block has access to injected variables `data` and `error` filled by the operation 

    fail if (error) { errorCode = error.code }

    return if (data === "Hello") data
  }
}

map Baz {
  # operations and maps can also make http requests
  http GET "example.com/api" {
    # the request object describes the request variables
    request {
      query {
        q = input.query # map also has access to the `input` variable from the usecase definition
      }

      headers {
        "content-type" = "application/json"
      }

      body {
        name = {
          first = "john"
          last = "doe"
        }
        address.zip = 123
      }
    }

    # the response blocks can filter specific responses
    response 200 "application/json" "en-US" {
      # mapping into the result mutates the map-global result variable
      map result {
        code = 200
        type = "json"
        lang = "en"

        # a special case of inline call
        # here the `data` is assigned to the text field
        # any failure produces an expection
        text = call Foo(body = response.body)
      }
    }

    response 200 {
      map result {
        code = 200
      }
    }

    response {
      # mapping into the error mutates the map-global error variable
      # once anything is mapped into the error, the map will result into an error mapping
      map error {
        code = response.code
      }
    }
  }

  # mapping into result/error does not end the execution, so cleanup can still be run
  call Bar(text = "error") if (map.error) {}

  # after the map finishes executing, the map-global `result` and `error` variables are returned as per the usecase definition
}